<?php
/**
  phpSec - A PHP security library

  @author    Audun Larsen <larsen@gmail.com>
  @copyright Copyright (c) Audun Larsen, 2011
  @link      https://github.com/xqus/phpSec
  @license   http://opensource.org/licenses/mit-license.php The MIT License
  @package   phpSec
 */

/**
 * Provides one time password functionality.
 */
class phpsecOtp {
  const HASH_TYPE = 'sha256';
  /**
   * Generate a one-time-password (OTP). The password is only valid for a given time,
   * and must be delivered to the user instantly. The password is also only valid
   * for the current session.
   *
   * @param string $action
   *   The action to generate a OTP for. This should be as specific as possible.
   *   Used to ensure that the OTP is used for the intended action.
   *
   * @param array $data
   *   Optional array of data that belongs to $action. Used to ensure that the action
   *   is performed with the same data as when the OTP was generated.
   *
   * @param integer $length
   *   OTP length.
   *
   * @param integer $ttl
   *   Time to live for the OTP. In seconds.
   *
   * @return string
   *   One time password that should be delivered to the user.
   *
   */
  public static function generate($action, $data = null, $length = 6, $ttl = 480) {
    $otp['pw'] = phpsecRand::str($length);
    if($data !== null) {
      $otp['hash'] = hash(self::HASH_TYPE, serialize($data));
    }
    phpsecCache::cacheSet('otp-'.$action, $otp, $ttl);

    return $otp['pw'];
  }

  /**
   * Validate a one-time-password.
   *
   * @param strgin $otp
   *   OTP supplied by user.
   *
   * @param string $action
   *   See phpsecOtp::generate().
   *
   * @param array $data
   *   See phpsecOtp::generate().
   *
   */
  public static function validate($otp, $action, $data = null) {
    $cache = phpsecCache::cacheGet('otp-'.$action);
    /* This is totally backwards. We check for what should not have been and
     * return false if we stuble across something fishy. Unless something good happened,
     * and we somehow did't find anything wrong. Then we return true. But if something really
     * bad happens we still return false. */
    if($cache !== false) {
      if($cache['pw'] !== $otp) {
        return false;
      } elseif(isset($cache['hash']) && $cache['hash'] !== hash(self::HASH_TYPE, serialize($data))) {
        return false;
      }
      return true;
    }
    return false;
  }

  /**
   * Create a list of 64 pre shared one-time-passwords,
   * or a so called password card.
   * This differs from phpsecOtp::generate() because passwords generated by
   * this function is saved permanent and can be validated on a later time.
   */
  public static function psGenerate() {
    $card['list'] = array();
    for($i = 0; $i < 64; $i++) {
      $card['list'][$i]   = phpsecRand::str(6);
      $card['usable'][$i] = true;
    }

    $card = self::psHash($card);
    self::psSave($card);

    return $card['id'];
  }

  /**
   * Validates a pre shared one-time-password.
   */
  public static function psValidate($cardId, $selected, $otp) {
    $card = self::psLoad($cardId);
    if($card['usable'][$selected] === true) {
      if($card['list'][$selected] == $otp) {
        $card['usable'][$selected] = false;

        $card = self::psHash($card);
        self::psSave($card);

        return true;
      }
    }
    return false;
  }

  /**
   * Select a pre shared OTP from a list that a user can use.
   */
  public static function psSelect($card) {

  }
  /**
   * Load a password card.
   */
  public static function psLoad($card) {
    $filename = phpsec::$_datadir.'/otp-card-'.$card;
    if(file_exists($filename)) {
      $card = json_decode(file_get_contents($filename), true);
      if($card['hash'] !== hash(self::HASH_TYPE, $card['list'])) {
        return false;
      }
      $card['list'] = json_decode(base64_decode($card['list']), true);
      return $card;
    }
    return false;
  }

  /**
   * Save a password card.
   */
  private static function psSave($card) {
    /* Save card. We should probably encrypt it first. */
    $fp = fopen(phpsec::$_datadir.'/otp-card-'.$card['id'], 'w');
    if($fp !== false) {
      fwrite($fp, json_encode($card));
      fclose($fp);
    }
  }

  /**
   * Prepeare the password card for saving.
   * Must be called before phpsecOtp::psSave().
   */
  private static function psHash($card) {
    /* We are encoding the password list just because we want to make
     * the file look nice, and to avoid bugs with special characters. */
    $card['list'] = base64_encode(json_encode($card['list']));
    $card['hash'] = hash(self::HASH_TYPE, $card['list']);
    $card['id']   = substr($card['hash'], 0, 12);

    return $card;
  }
}